use super::*;
use crate::{ColumnSample, Land, util::RandomField};
use common::terrain::{Block, BlockKind};
use itertools::Itertools;
use rand::prelude::*;
use util::sprites::PainterSpriteExt;
use vek::*;

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum RoadKind {
    Default,
    Terracotta,
}

/// Represents house data generated by the `generate()` method
pub struct Road {
    pub path: Path<Vec2<i32>>,
    pub kind: RoadKind,
}

impl Structure for Road {
    #[cfg(feature = "use-dyn-lib")]
    const UPDATE_FN: &'static [u8] = b"render_road\0";

    #[cfg_attr(feature = "be-dyn-lib", export_name = "render_road")]
    fn render_inner(&self, site: &Site, land: &Land, painter: &Painter) {
        let place_light = |pos: Vec3<i32>, dir: Dir| match self.kind {
            RoadKind::Default => painter.lanternpost_wood(pos, -dir),
            RoadKind::Terracotta => painter.sprite(pos, SpriteKind::LampTerracotta),
        };

        let field = RandomField::new(76237);

        for (previous, p, next) in self.path.iter().tuple_windows::<(_, _, _)>() {
            if (p + p.yx() / 2) % 2 != Vec2::zero() {
                continue;
            }

            let TileKind::Road { w, .. } = site.tiles.get(*p).kind else {
                continue;
            };

            let prev_dir = Dir::from_vec2(*previous - *p);
            let next_dir = Dir::from_vec2(*next - *p);

            let mut dir_a = prev_dir.rotated_cw();
            if dir_a == next_dir {
                dir_a = dir_a.rotated_cw();
            }
            let mut dir_b = dir_a.rotated_cw();
            if dir_b == next_dir {
                dir_b = dir_b.rotated_cw();
            }

            let width = w as i32 * 2 - 1;
            let tile_wpos = site.tile_wpos(*p);
            let orth = if field.chance(p.with_z(11), 0.5) {
                dir_a
            } else {
                dir_b
            };
            let wpos = tile_wpos + orth.to_vec2() * width;

            // TODO: Not sure if this is always correct
            let alt = land.get_alt_approx(wpos) as i32 + 1;
            let wpos = wpos.with_z(alt);
            place_light(wpos, orth);
        }
    }

    fn terrain_surface_at<R: Rng>(
        &self,
        wpos: Vec2<i32>,
        old: Block,
        _rng: &mut R,
        col: &ColumnSample,
        z_off: i32,
        site: &Site,
    ) -> Option<Block> {
        match z_off {
            0 => {
                let tpos = site.wpos_tile_pos(wpos);
                let mut near_roads = CARDINALS.iter().filter_map(|rpos| {
                    let tile = site.tiles.get(tpos + rpos);
                    if let TileKind::Road { a, b, w } = &tile.kind {
                        if let Some(PlotKind::Road(Road { path, .. })) =
                            tile.plot.map(|p| &site.plot(p).kind)
                        {
                            Some((
                                LineSegment2 {
                                    start: site
                                        .tile_wpos(path.nodes()[*a as usize])
                                        .map(|e| e as f32),
                                    end: site
                                        .tile_wpos(path.nodes()[*b as usize])
                                        .map(|e| e as f32),
                                },
                                *w,
                            ))
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                });

                let wposf = wpos.map(|e| e as f32);
                if near_roads.any(|(line, w)| line.distance_to_point(wposf) < w as f32 * 2.0) {
                    let sub_surface_color = col.sub_surface_color * 0.5;
                    Some(Block::new(
                        BlockKind::Earth,
                        (sub_surface_color * 255.0).as_(),
                    ))
                } else {
                    None
                }
            },
            1.. => Some(old.into_vacant()),
            _ => None,
        }
    }
}
